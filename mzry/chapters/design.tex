% !Mode:: "TeX:UTF-8"

\chapter{系统详细设计}
\section{服务器端详细设计}
在服务器端系统设计过程中，最重要的是根据需求分析及用例模型构建系统静态模型和动态模型。顺序图展示对象之间的交互，这些交互是指在场景或用例的事件流中发生的。协作图是一种交互图，强调的是发送和接收消息的对象之间的组织结构，使用协作图来说明系统的动态情况。状态图说明对象在它的生命期中响应事件所经历的状态序列，以及它们对那些事件的响应。活动图是主要用于业务建模时，用于详述业务用例，描述一项业务的执行过程。设计时，描述操作的流程\cite{zhanghaipan1998}。

\subsection{系统顺序图}
我们用顺序图来说明用户的一次操作在系统之中是如何完成的，通过顺序图来对本系统的工作机制提供一个大概的说明，图\ref{BackendSequence}说明了用户的一次完整操作。

\pic[htbp]{系统顺序图}{width=\textwidth}{BackendSequence}

\subsection{系统包图}
包图说明了系统各个模块之间的依赖关系，在\ref{sec:serverModelStructure}中我们已经介绍过了系统的模块结构，根据这个结构，本系统的包结构如图\ref{ServerPackage}所示。由于本系统内容比较多，我们这里先给出大概的结构，后面再一一详细描述。
\pic[htb]{包图}{}{ServerPackage}

\subsection{Config Package详细设计}

\pic[htbp]{Config Package类图}{}{ConfigPackage}

\subsubsection{ApplicationContextConfig}
ApplicationContextConfig.java见附录\ref{sec:ApplicationContextConfig}。

Spring框架有两种配置方式，一种是通过XML配置文件进行配置，这种方式将所有的配置信息写入一个指定的XML文件之中，这种方式略显麻烦，在本文中我们采用了另外一种方式，这种方式是利用Java的Annotation机制来进行配置。

系统启动时默认将resources.properties文件\footnote{resources.properties见附录\ref{sec:resources}。}中的键值对初始化成一个Environment实例，我们可以通过getProperty(String): String方法来获得对应的值。

有了\textbf{Environment}实例，我们就可以将配置信息从代码中分离开来。

\subsubsection{WebMVCResource}
WebMVCResource.java见附录\ref{sec:WebMVCResource}。

为了方便进行测试，我们将一些比较特殊的资源从WebMVCConfig.java中独立开来，放到WebMVCResource.java中。这里主要做了两件事情：一个是配置视图解析器，在这里我们设置视图地址的前缀和后缀，方便Controller调用视图。另外一件事就是配置了JSON数据的转换器，用于解析和构建JSON数据，这里我们使用了fastjson\footnote{Fastjson是一个Java语言编写的JSON处理器,由阿里巴巴公司开发。}。

\subsubsection{WebMVCConfig}
WebMVCConfig.java见附录\ref{sec:WebMVCConfig}
这个文件是SpringMVC框架的配置文件，与之前的ApplicationContextConfig类似，这里配置了与Web相关的参数。

\subsection{Database Package详细设计}
\pic[htbp]{Database Package包图}{}{DatabasePackage}

这个包在MVC模型中处于Model层，所有与数据库有关的API都被包含在里面。

\subsubsection{Entity}
\pic[htbp]{Entity Package类图}{}{EntityPackage}

Entity即为实体，对应着MVC模型中的Model，它和数据库中的内容有着直接的一对一映射关系。本系统数据库较为复杂，详细数据库结构图见附录\ref{sec:databasediagram}。这里我们简述一下各个实体的作用，如表\ref{entitytable}所示

%\longthreelinetable{entitytable}{Entity表}{2}{ll}
\threelinetable[htbp]{entitytable}{\textwidth}{ll}{Entity表}
{Entity & 作用\\
}{
Article & 文章的内容和基本信息\\
Code & 用户提交的代码\\
CompileInfo & 代码的编译信息\\
Contest & 比赛的基本信息\\
ContestProblem & 比赛和题目的对应关系\\
ContestTeamInfo & 参赛队伍的信息\\
ContestUser & 比赛的注册用户\\
Department & 学校的部门信息\\
Language & 可以使用的语言以及参数\\
Message & 用户短消息\\
Problem & 题目内容和基本信息\\
ProblemTag & 题目和分类标签的对应关系\\
Status & 代码的评测状态\\
Tag & 分类标签\\
User & 用户信息\\
UserSerialKey & 用户激活码\\
}{
}

\subsubsection{DTO}
\pic[htbp]{DTO Package类图}{}{DTOPackage}

数据传输对象DTO有两种，一种是客户端向服务器传输的数据，一种是模型向上层传输的数据。前者我们通过一个简单的类可以实现。

Hibernate自带的数据库API较为复杂，为了提升效率和简化代码维护成本，我们自己构建了一套用来提取数据库数据的工具。在这类DTO中，我们使用了一个\textbf{@Fields}注解来注明这个DTO的信息来自数据库中的哪些域，然后通过这个field来构建HQL查询语言的\textbf{SELECT}命令。如下所示为UserListDTO.java的部分内容：

\input{code/FieldAnnotation.java.tex}

对应生成的HQL语句为\textbf{SELECT userId, email, userName, nickName, type, school, motto, lastLogin, solved, tried FROM User}，配合接下来要介绍到的Condition，我们可以组合出基本的HQL查询语句。

在得到这些域后，我们调用对应的EntityDTOBuilder的build方法来得到这些值。

\subsubsection{Condition}
\pic[htbp]{Condition Package类图}{}{ConditionPackage}

我们在本系统中使用Hibernate作为持久层框架，它提供了强大的HQL查询语言，Condition包的主要功能就是提供了Condition组件，它可以翻译成HQL查询语言的where条件，来限定检索范围。

根据实际情况，本系统设计的Condition支持三种条件：
\begin{enumerate}
	\item Order条件：用来限定返回结果的顺序。
	\item PageInfo条件：用来实现返回结果的分页功能。
	\item 普通条件：既Entry，它既可以是一条普通的条件，如\textbf{userId = 5}，也可以是一个Condition。在枚举类型ConditionType中，我们定义了许多常用的条件，如等于、不等于、小于、like、属于等等。
\end{enumerate}

对于每个数据库实体类型Entity，都有一个对应的EntityCondition类，如Problem实体有对应的ProblemCondition。这些EntityCondition类都必须继承自BaseCondition类，并且实现它的\textbf{getCondition()}方法。

对于一些比较简单的条件，我们提供了一个\textbf{@Exp}注解，例如在StatusCondition.java中有如下变量：

\input{code/ExpAnnotation.java.tex}

如果这两个成员变量不是空，那么最后我们会得到一个形式如同\textbf{WHERE ... userId $>=$ userId and userByUserId $=$ userId ...}的HQL查询语句。

对于一些比较复杂的条件，开发者可以在\textbf{getCondition()}方法中实现复杂的逻辑。

\subsubsection{DAO}
\pic[htbp]{DAO Package类图}{}{DAOPackage}

DAO提供了基础的数据库操作API，例如添加数据、修改、删除、查询等等，通过与DTO和Condition的配合使用，我们可以方便的进行数据库操作，而不需要为每种情况都生成一段冗长的HQL语句。

\subsection{Service Package详细设计}
\pic[htbp]{Service Package类图}{}{ServicePackage}

Service为上层应用提供了一系列特定的数据库操作，根据接口隔离原则\cite{szyperski2002component}，我们不希望上层应用直接调用底层的数据库API来进行操作，我们通过Service来隔离它们。在这里，每个EntityService都完成与指定Entity相关的操作，不允许出现跨Entity的调用。

\subsection{Judge Package详细设计}
这个Package包含了与评测器服务相关的内容。

\subsubsection{评测器内核}
评测器内核负责编译、运行、评测用户代码，是一个控制台程序，通过命令行参数来设定评测任务。评测器内核的主函数参数表见表\ref{judgecoredescription}。
%\longthreelinetable{judgecoredescription}{Judge Core参数}{2}{ll}
\threelinetable[htbp]{judgecoredescription}{\textwidth}{ll}{Judge Core参数}
{参数 & 作用\\
}{
-u & 指定任务ID\\
-s & 指定源代码路径\\
-n & 指定题目ID\\
-D & 指定数据文件夹地址\\
-d & 指定运行的工作目录\\
-t & 指定运行时间限制\\
-m & 指定运行内存限制\\
-o & 指定输出大小限制\\
-S & 开启SPJ选项\\
-l & 指定语言类型\\
-I & 指定测试用例的输入文件\\
-O & 指定-I中测试用例的对应标准输出文件\\
-C & 是否需要编译\\
}{
}

评测结束后，它返回三个整数，分别代表评测结果、内存开销、时间开销。

\subsubsection{JudgeService}
\pic[htbp]{Judge Package类图}{}{JudgePackage}
\pic[htbp]{Judge Service活动图}{}{JudgeActivity}
JudgeService在系统启动时开始运行\footnote{见附录\ref{sec:ApplicationContextConfig}的22-26行。}，在这个类中我们用队列judgeQueue作为评测器的调度队列。它生成schedulerThread线程用来等待评测任务的到来，它每隔一定的时间间隔（在这里我们设置为3秒）调用StatusService查找所有等待测试的任务，将其标记为OJ\_JUDGING状态，并加入到judgeQueue中。它还配置了若干个JudgeThread线程用来进行多线程评测操作。每个JudgeThread不停的扫描judgeQueue，直到任务的到来，它首先将代码保存至工作目录下，然后构造控制台命令调用\textbf{Runtime.getRuntime().exec(shellCommand)}来和评测器内核交互，并得到结果，然后依据结果来做出相应的更新。如图\ref{JudgeActivity}所示。

\subsection{Web Package详细设计}
\pic[htbp]{Web Package类图}{}{WebPackage}
Web Package主要包含的是控制器，以及为控制器服务的一些模块，比如权限验证模块。

\subsubsection{AuthenticationAspect}
这是本系统的权限验证模块，我们采用了面向侧面的程序设计\footnote{aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程，是计算机科学中的一个术语，指一种程序设计范型。该范型以一种称为侧面（aspect，又译作方面）的语言构造为基础，侧面是一种新的模块化机制，用来描述分散在对象、类或函数中的横切关注点（crosscutting concern）。}思想来完成，既在每个Controller之前``切入''一段指定的代码来进行权限验证。这部分我们使用AspectJ框架来完成，它是以代理（Proxy）的形式实现的。代码见附录\ref{sec:AuthenticationAspect}。

我们在图\ref{AuthenticationSequence}给出了验证成功和验证失败的两个顺序图，可以看到当验证失败时，我们不会调用原Controller，达到了权限限制的目的。

\begin{pics}[htbp]{权限验证顺序图}{AuthenticationSequence}
\addsubpic{一次失败的权限验证}{}{ControllerSequenceFail}
\addsubpic{一次成功的权限验证}{}{ControllerSequenceSuccess}
\end{pics}

\subsubsection{Controller}
Spring MVC框架提供了很强大的Controller，我们只需要在一个类上使用\textbf{@Controller}注解就可以将一个类声明为控制器。在本项目中，我们按照域名的分布来划分Controller，在前面的图\ref{front-end-structure}中我们已经给出网站的结构。

根据返回值的不同，控制器分为两种类型：一种是返回一个代表视图地址的\textbf{String}的控制器，一种是返回一个代表JSON数据的\textbf{@ResponseBody Map$<$String, Object$>$}的控制器。

视图保存在项目的webapp目录下，如\textbf{webapp/WEB-INF/views/index/index.jsp}，此视图对应的地址为\textbf{/WEB-INF/views/index/index.jsp}，但是我们在WebMVCResource.java（附录\ref{sec:WebMVCResource}）中的\textbf{viewResolver()}设置了地址的前缀和后缀，我们可以将其简写为\textbf{index/index}。如果控制器返回了一个视图地址，那么服务器会将对应的页面返回给用户。

对于返回\textbf{@ResponseBody Map$<$String, Object$>$}的控制器，FastJson框架会将这个\textbf{@ResponseBody Map$<$String, Object$>$}转换成JSON各式的文本返回给用户。

下面我们用用户登陆相关的控制器来说明它是如何工作的（代码省略了其余部分）。

\input{code/UserController.java.tex}

我们使用\textbf{@RequestMap}注解来声明方法所对应的网址，\textbf{@LoginPermit}定义了该地址的权限。因为Spring通过反射机制来进行自动注入，控制器方法的参数可以以任意顺序排列而不需要指定顺序。在login方法中，除了\textbf{HttpSession session}参数以外，另外两个和前端POST来的数据相关，\textbf{@RequestBody @Valid UserLoginDTO userLoginDTO}用来保存前端POST来的数据，我们使用了Java验证框架来对前端传递的数据进行一个初步的合法性验证，\textbf{@Valid}注解说明了我们需要对\textbf{userLoginDTO}进行验证，验证的结果保存在\textbf{BindingResult validateResult}中，下面是\textbf{UserLoginDTO}的部分代码：

\input{code/UserLoginDTO.java.tex}

顺利登陆之后，前端可以接收到类似如下格式的一段数据：

\input{code/loginResult.txt.tex}

\subsubsection{网站地图}
上面我们举例说明了UserController的login方法的实现，限于篇幅限制其余的部分我们不一一描述，在这里我们给出整个网站的网站地图，介绍各个控制器的作用和返回给前端的数据类型。

\longthreelinetable{sitemap}{网站地图}{5}{lllll}
{
地址  & 控制器 & 方法 & 作用 & 返回类型\\
}{
/admin/ & AdminController & index & 管理员面板 & HTML\\

/article/data/{type}/{articleId} & ArticleController & data & 文章数据 & JSON\\
/article/show/{articleId} & ArticleController & show & 文章页面 & HTML\\
/article/search & ArticleController & search & 文章查找 & JSON\\
/article/editor/{articleId} & ArticleController & editor & 文章编辑器 & HTML\\
/article/edit & ArticleController & edit & 文章编辑 & JSON\\
/article/operator & ArticleController & operator & 文章操作 & JSON\\

/contest/status/{contestId}/{lastFetched} & ContestController & status & 比赛评测结果 & JSON\\
/contest/rankList/{contestId} & ContestController & rankList & 比赛排名 & JSON\\
/contest/data/{contestId} & ContestController & data & 比赛数据 & JSON\\
/contest/show/{contestId} & ContestController & show & 比赛页面 & HTML\\
/contest/list/{contestId} & ContestController & list & 比赛列表 & HTML\\
/contest/search & ContestController & search & 比赛查找 & JSON\\
/contest/operator/{id}/{field}/{value} & ContestController & operator & 比赛操作 & JSON\\
/contest/editor/{contestId} & ContestController & editor & 比赛编辑器 & HTML\\
/contest/edit & ContestController & edit & 比赛编辑 & JSON\\
}

\section{浏览器端详细设计}
一个好的Web应用不仅仅要拥有功能完善的后台，还应该拥有一个友好的界面。下面我们
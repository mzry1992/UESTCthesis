% !Mode:: "TeX:UTF-8"

\chapter{MVC架构}
在现代浏览器拥有越来越丰富的新特性的当下，构建功能成熟的web应用已经不再是一件困难的事，而是更多开发者的选择。通过对网络中的HTTP数据的分析，目前已经部署的JavaScript代码在上一年之中增长了45\%。

\pic[htbp]{JS Transfer Size \& JS Requests}{width=\textwidth}{jstransferrequests}

随着JavaScript变得越来越流行，客户端应用也变得越来越复杂。开发一个应用需要许多开发者的合力协作。书写\textbf{维护性}与\textbf{复用性}强的代码成为了当今web应用时代的关键。Chrome应用——以及它丰富的特性，也不例外。

设计模式在如何书写维护性与复用性良好的代码中扮演着重要的角色。在我们的案例中，当我们构建一个Chrome应用时，一个可复用的模式可以应用于在软件设计中遇到的许许多多常见的问题。我们建议开发者们通过MVC模式将应用分解成一系列相互独立的部分。

在最近几年，一系列基于JavaScript的MVC框架先后问世：backbone.js, ember.js，AngularJS，Sencha，Kendo UI……它们各有特点，但是都遵守MVC模式——为了让开发者写出更加结构化的JavaScript代码。


\section{MVC模式概览}
MVC模式在标准JavaScript之上提供了一个有益的架构——它帮助我们写出更有组织性的，维护性强的代码。这种模式还被应用于许多编程语言，并且通过了几代程序员的广泛考验。

MVC模式由三部分组成：

\pic[htbp]{MVC}{width=0.9\textwidth}{mvc}


\subsection{模型（Model）}
模型被用于储存应用程序的数据对象。模型不知道视图和控制器的任何细节。当一个模型发生了改变，它会将这个改变通知它的观察者们。

为了理解这种特性，让我们看看这个待办列表应用，它是一个简单的能够管理用户的任务列表的单页应用。

\pic[htbp]{待办列表应用}{width=0.6\textwidth}{todos}

在这里模型被用于表示每个待办项目的属性，例如描述（description）和状态（status）。每当一个新的待办项目被建立时，它被保存在该模型的一个新的实例中。


\subsection{视图（View）}
视图被用于向用户展示数据以及与用户进行交互。视图由HTML，CSS，JavaScript和模板组成。在你的Chrome应用当中，视图可以访问文档对象模型（DOM）。

举例来说，在上面的待办列表应用中，开发者创建了一个很不错的视图用来向用户展示待办列表项。用户可以通过一些固定的输入格式来新建一个新的待办事项，但是要注意一点：视图并不知道如何对模型进行更新操作，这是由控制器来完成的任务。


\subsection{控制器（Controller）}
控制器被用于逻辑控制和充当模型与视图之间的``胶水''。当模型发生改变时，控制器更新对应的视图。除此之外，控制器还可以给视图添加事件监听器，当用户对视图进行操作的时候来通知模型做出对应的更改。

在待办列表应用中，当用户将一条待办事项标记为完成时，这个单击事件被发送给控制器。控制器收到请求后对对应的模型做出修改，将其状态标记为完成。通常它还会与服务器进行一次保存操作来持久化保存这次修改。在一些功能强大的客户端应用（例如Chrome应用）中，有时也需要将数据保存在本地。在这种情况下，控制器也可以用类似于FileSystem API的工具将数据保存在客户端。

MVC模式有一些变种，比如MVP（模型-视图-呈现）和MVVP（模型-视图-视图模型）。甚至对于的MVC设计模式，在传统的MVC模式和不同语言的实现中也存在许许多多的变种。例如有些基于MVC的框架通过监视模型的变化来直接修改视图，而有些则是通过控制器来更新视图。这篇文章的重点不在于比较这些不同的实现方法，而是专注于关注关注点分离这项在现代web应用中被广泛应用的技术。

如果你对此有兴趣的话，我们推荐你Addy Osmani的在线书籍《Learning JavaScript Design Patterns》。

最后，我们来总结一下，MVC模式给应用开发者带来了模块化的能力以及一下特性：
\begin{itemize}
  \item 可复用易扩展的代码。
  \item 将视图逻辑和操作逻辑分离。
  \item 允许许多开发者同时进行不同模块的开发（例如UI和核心逻辑）。
  \item 易于维护。
\end{itemize}


\section{MVC持久化模式}
MVC框架有许许多多不同的方法来实现持久化操作，每种都各有优点。在开发Chrome应用时，通常选择适合你和你的应用的框架。

\subsection{在模型中完成持久化——活动记录模式}
活动记录模式（ActiveRecord）流行于许许多多服务器端框架（例如Ruby on Rails）和客户端框架（例如Backbone.js和ember.js）中，在活动记录模式中，模型自己实现持久化的职责，例如通过JSON API来实现。

用模型来处理持久化操作的不同之处在于它引入了数据源和适配器函数的关注分离。数据源，模型和适配器（在某些框架中被称作代理）协同工作。数据源被用来保存所有的模型，同时它还提供了一些函数（例如创建、查询、过滤）来操作它包含的模型实例。

适配器（或者代理）收到来自数据源的请求后将其翻译成合适的操作来对与持久层进行交互（例如JSON API）。这在现代的web应用设计中是很重要的，因为你通常会使用不止一种持久层（例如远程服务器和本地浏览器数据）。在客户端数据中，Chrome应用提供了Chrome Storage API和HTML5 fileSystem API两种不同的选择。

优点：
\begin{itemize}
  \item 使用简单，便于理解。
\end{itemize}

缺点：
\begin{itemize}
  \item 不便于测试，持久层被绑定在模型当中。
  \item 同时使用使用着不同的数据源的模型是很困难的（例如同时使用文件系统、索引数据库与服务器端中的数据）。
  \item 复用其它应用中的模型会带来冲突，例如在两个不同的视图中贡献同一个模型，而且这两个视图想要将其储存于不同的地方时。
\end{itemize}


\subsection{在控制器中完成持久化}
在这种模式中，控制器保存了模型的一个引用以及它在数据源中对应的位置。控制器对模型生命周期中的事件作出相应（例如加载，保存，删除），然后在数据源中用对应的命令来获取和更新模型。

优点：
\begin{itemize}
  \item 便于测试，控制器可以通过注入一个模拟的数据源对象来完成测试。
  \item 同一个模型可以在不同的数据源中复用（只需要建立使用对应数据源的控制器即可）。
\end{itemize}

缺点：
\begin{itemize}
  \item 代码将会变得复杂且难以维护。
\end{itemize}


\subsection{在应用控制器中完成持久化}
在一些模式中，有一个应用控制器来监控不同MVC之间的切换操作。例如``后退''按钮将当前页面从编辑窗口（包括了许多MVC控件和格式）切换到设置窗口这个事件是由这个应用控制器来决定的。

在应用控制器模式中，应用控制器响应事件，并且改变应用的当前窗口，向数据源获取任何需要加载的模型，创建窗口中需要的视图和控制器。

优点：
\begin{itemize}
  \item 将持久层移动到了更高的层次，便于修改。
  \item 底层控制器不需要关系持久层的实现，保持代码的纯净。
\end{itemize}

缺点：
\begin{itemize}
  \item 每个页面都需要一系列重复的文件需要完成：模型、视图、控制器、应用控制器。
\end{itemize}
